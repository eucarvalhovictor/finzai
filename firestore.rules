/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all user data is sandboxed.
 * Data is only accessible to the authenticated user who owns it, ensuring high levels of privacy and security
 * for sensitive financial information.
 *
 * Data Structure: All data is hierarchically organized under the top-level `/users` collection. Each user's
 * data, including credit cards, transactions, and investment accounts, is stored in subcollections
 * under their specific document path, e.g., `/users/{userId}/creditCards/{creditCardId}`. This structure
 * naturally isolates user data.
 *
 * Key Security Decisions:
 * - User Listing Disabled: To protect user privacy, it is impossible to list all documents in the `/users`
 *   collection. This prevents enumeration of the entire user base.
 * - Path-Based Authorization: All authorization checks are based on the document path. A user's UID must
 *   match the `{userId}` segment in the path to gain access.
 * - Relational Integrity: On document creation, rules enforce that an internal `userId` field must match the
 *   `userId` in the path, creating a durable and secure link between the data and its owner. This field
 *   is immutable on updates.
 * - Default Deny: Access is denied by default. All permissions are granted explicitly through specific `allow`
 *   statements.
 *
 * Denormalization for Authorization: The entire security model is built on structural denormalization. By nesting
 * all user-specific data under a `/users/{userId}` path, authorization becomes simple and performant. There is
 * no need for costly `get()` calls to other documents to verify ownership, as ownership is determined by the path itself.
 *
 * Structural Segregation: This ruleset perfectly exemplifies structural segregation. All user data is inherently private
 * and contained within user-specific subcollections. There are no mixed-privacy collections, which simplifies list
 * operations and enhances security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner and the resource already exists.
     * Used for all state-changing update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && exists(/databases/$(database)/documents/$(request.path.split('/')[1])/$(userId));
    }

    /**
     * Validates that a user is creating their own root user document and that
     * the document's internal `id` field matches their auth UID for integrity.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates that the user document's internal 'id', 'email', and 'registrationDate' fields remain unchanged during an update.
     * This is a critical security measure for user profile updates.
     */
    function areUserCoreFieldsImmutable() {
      // Check if the incoming request data attempts to change any of the core immutable fields.
      // If a field exists in the request, it MUST match the existing value in the database.
      let idIsUnchanged = !('id' in request.resource.data) || request.resource.data.id == resource.data.id;
      let emailIsUnchanged = !('email' in request.resource.data) || request.resource.data.email == resource.data.email;
      let registrationDateIsUnchanged = !('registrationDate' in request.resource.data) || request.resource.data.registrationDate == resource.data.registrationDate;

      return idIsUnchanged && emailIsUnchanged && registrationDateIsUnchanged;
    }


    /**
     * Validates that a user is creating a document in their own subcollection
     * and that the document's internal `userId` field matches their auth UID.
     */
    function isCreatingOwnSubcollectionDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that a subcollection document's internal `userId` field remains unchanged during an update.
     */
    function isSubcollectionDocOwnerIdImmutable() {
      return !('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId;
    }

    // -------------------------------------------------------------------------
    // User Profiles (/users)
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document if their UID matches the document ID.
     * @deny (list) An attacker cannot list all documents in the `/users` collection to harvest user IDs.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnUserDoc(userId);
      allow update: if isExistingOwner(userId) && areUserCoreFieldsImmutable();
      allow delete: if isExistingOwner(userId);

      // -----------------------------------------------------------------------
      // User Subcollections
      // -----------------------------------------------------------------------

      /**
       * @description Manages credit cards owned by a specific user.
       * @path /users/{userId}/creditCards/{creditCardId}
       * @allow (create) An authenticated user can create a credit card document within their own user path.
       * @deny (get) A user `user-abc` cannot read a credit card document from `user-xyz`'s path.
       * @principle Enforces strict data ownership for all CRUD and list operations within a user's private subcollections.
       */
      match /creditCards/{creditCardId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnSubcollectionDoc(userId);
        allow update: if isExistingOwner(userId) && isSubcollectionDocOwnerIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages investment accounts owned by a specific user.
       * @path /users/{userId}/investmentAccounts/{investmentAccountId}
       * @allow (list) An authenticated user can list all investment accounts within their own user path.
       * @deny (create) A user cannot create an investment account document in another user's path.
       * @principle Enforces strict data ownership for all CRUD and list operations within a user's private subcollections.
       */
      match /investmentAccounts/{investmentAccountId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnSubcollectionDoc(userId);
        allow update: if isExistingOwner(userId) && isSubcollectionDocOwnerIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages financial transactions for a specific user.
       * @path /users/{userId}/transactions/{transactionId}
       * @allow (update) An authenticated user can update a transaction within their own user path.
       * @deny (delete) A user `user-abc` cannot delete a transaction belonging to `user-xyz`.
       * @principle Enforces strict data ownership for all CRUD and list operations within a user's private subcollections.
       */
      match /transactions/{transactionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnSubcollectionDoc(userId);
        allow update: if isExistingOwner(userId) && isSubcollectionDocOwnerIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages AI-generated budget suggestions for a specific user.
       * @path /users/{userId}/budgetSuggestions/{budgetSuggestionId}
       * @allow (get) An authenticated user can read a budget suggestion generated for them.
       * @deny (list) An anonymous user cannot list budget suggestions for any user.
       * @principle Enforces strict data ownership for all CRUD and list operations within a user's private subcollections.
       */
      match /budgetSuggestions/{budgetSuggestionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnSubcollectionDoc(userId);
        allow update: if isExistingOwner(userId) && isSubcollectionDocOwnerIdImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
